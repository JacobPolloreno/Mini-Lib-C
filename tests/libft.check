#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <time.h>
#include <unistd.h>
#include "libft.h"

void	string_to_upper(char *s)
{
	*s = ft_toupper(*s);
}

char	*map_upper_str(char *s)
{
	char *res;
	int len;

	if ((res = (char *)ft_memalloc(sizeof(*res) * ft_strlen(s) + 1)))
	{
		len = 0;
		while (*s)
			res[len++] = ft_toupper(*s++);
		return (res);
	}
	return (NULL);
}

void	string_to_idx(unsigned int idx, char *s)
{
	*s = '0' + idx;
}

char	char_to_upper(char c)
{
	return ((char)ft_toupper(c));
}

char	char_to_idx(unsigned int idx, char c)
{
	(void)c;
	return ('0' + idx);
}

void	lst_del_str(void *content, size_t content_size)
{
	if (content_size)
		free(content);
}

void	print_lst_content(t_list *node)
{
	ft_putstr_fd((char *)node->content, 1);
}

t_list	*create_elem_map(t_list *node)
{
	t_list *new;
	char	*new_str;

	if (!node)
		return (NULL);
	new_str = map_upper_str((char *)node->content);
	if (!(new = ft_lstnew(&new_str, ft_strlen((char *)node->content))))
		return (NULL);
	return (new);
}

char	strmap_call(char s)
{
	return (s + 1);
}

int		btree_cmpf_int(void *d1, void *d2)
{
	int nb1;
	int nb2;

	nb1 = *((int *)d1);
	nb2 = *((int *)d2);
	return (nb1 - nb2);
}

void	btree_deletef_int(t_btree **node)
{
	if (!node)
		return ;
	free(*node);
	*node = NULL;
}

void	*btree_updatef_int(void **data, void *new_data)
{
	(void)data;
	return (new_data);
}

void	btree_print_int(void *data)
{
	printf("%d ", *(int *)data);
}

void	stack_print_int(void *data)
{
	ft_putnbr(*(int*)data);
}

#test check_bzero
	char str[20] = "42 is a school";
	char str2[20] = "42 is a school";

	printf("CHECKING BZERO...\n");
	bzero(str + 3, 8 * sizeof(char));
	ft_bzero(str2 + 3, 8 * sizeof(char));

	ck_assert_str_eq("42 ", str);
	ck_assert_str_eq("42 ", str2);
	ck_assert_str_eq(str, str2);
	ck_assert_str_ne(str, "42 is a school");
	ck_assert_str_ne(str2, "42 is a school");

#test check_memccpy
	const char *src = "42 is a school.";
	char	bf1[] = "abcdefghijklmnopqrstuvwxyz";
	char	bf2[] = "abcdefghijklmnopqrstuvwxyz";
	char	*src2 = "string with\200inside !";
	char buff[50];
	char buff2[50];
	char *dest;
	char *dest2;

	printf("CHECKING MEMCCPY...\n");
	dest = memccpy(buff, src, '2', strlen(src) + 1);
	dest2 = ft_memccpy(buff2, src, '2',  strlen(src) + 1);
	*dest = '\0';
	*dest2 = '\0';
	dest -= 2;
	dest2 -= 2;
	ck_assert_int_eq(strlen(dest), 2);
	ck_assert_int_eq(strlen(dest2), 2);
	ck_assert_str_eq(dest, "42");
	ck_assert_str_eq(dest2, "42");
	ck_assert_str_eq(dest2, dest2);

	/* ck_assert_str_eq(dest, src); */
	/* ck_assert_str_eq(dest2, src); */
	/* ck_assert_str_eq(dest, dest2); */

	memccpy(bf1, src2, '\200', 21);
	ft_memccpy(bf2, src2, '\200', 21);
	ck_assert_str_eq(bf1, bf2);

#test check_memchr
   const char str[] = "http://www.42siliconvalley.com";
   const char ch = '.';
   char *src = "/|\x12\xff\x09\x42\2002\42|\\";
   int size;
   char *ret;
   char *ret2;

   printf("CHECKING MEMCHR...\n");
   size = 10;
   ret = memchr(str, ch, strlen(str));
   ret2 = ft_memchr(str, ch, strlen(str));
   ck_assert_str_eq(ret, ".42siliconvalley.com");
   ck_assert_str_eq(ret2, ".42siliconvalley.com");
   ck_assert_ptr_eq(ret, ret2);
   ck_assert_ptr_eq(memchr(src, '\200', size), ft_memchr(src, '\200', size));

#test check_memcmp
	char str1[15];
	char str2[15];
	char longstr1[9999];
	char longstr2[9999];
	int ret;
	clock_t t;
	double time_taken;

	printf("CHECKING MEMCMP...\n");
	memcpy(str1, "abcdef", 6);
	memcpy(str2, "ABCDEF", 6);

	//ck_assert_int_eq(memcmp("", "", 0), ft_memcmp("", "", 0));
	//ck_assert_int_eq(memcmp("", "", 1), ft_memcmp("", "", 1));
	//ck_assert_int_eq(memcmp("Z", "Z", 1), ft_memcmp("Z", "Z", 1));
	//ck_assert_int_eq(memcmp("a", "b", 1), ft_memcmp("a", "b", 1));
	//ck_assert_int_eq(memcmp("b", "a", 1), ft_memcmp("b", "a", 1));
	//ck_assert_int_eq(memcmp("a", "A", 1), ft_memcmp("a", "A", 1));
	//ck_assert_int_eq(memcmp("ABx", "ABX", 3), ft_memcmp("ABx", "ABX", 3));

	t = clock();
	ret = memcmp(str1, str2, 5);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tMemcmp took %f to execute\n", time_taken);
	ck_assert_int_gt(ret, 0);

	t = clock();
	ret = ft_memcmp(str1, str2, 5);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tft_memcmp took %f to execute\n", time_taken);
	ck_assert_int_gt(ret, 0);

	memset(longstr1, 'a', 9999);
	memset(longstr2, 'a', 9999);

	t = clock();
	ret = memcmp(longstr1, longstr2, 9999);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tMemcmp took %f to execute\n", time_taken);
	ck_assert_int_eq(ret, 0);

	t = clock();
	ret = ft_memcmp(longstr1, longstr2, 9999);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tft_memcmp took %f to execute\n", time_taken);
	ck_assert_int_eq(ret, 0);

#test check_memcpy
	const char *src = "42 is a school.";
	char dest[50];
	char dest2[50];
	char long_src[9999];
	char long1[9999];
	char long2[9999];
	clock_t t;
	double time_taken;

	printf("CHECKING MEMCPY...\n");
	memcpy(dest, src, strlen(src) + 1);
	ft_memcpy(dest2, src, strlen(src) + 1);
	ck_assert_str_eq(dest, src);
	ck_assert_str_eq(dest2, src);
	ck_assert_str_eq(dest, dest2);

	ft_bzero(long_src, 9999);

	t = clock();
	memcpy(long1, long_src, 9999);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	printf("\tMemcpy took %f to execute\n", time_taken);

	t = clock();
	ft_memcpy(long2, long_src, 9999);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	printf("\tft_memcpy took %f to execute\n", time_taken);

#test check_memmove
	char csrc[100] = "Geeksfor";
	char csrc2[100] = "Geeksfor";

	printf("CHECKING MEMMOVE...\n");
	memmove(csrc + 5, csrc, strlen(csrc) + 1);
	ft_memmove(csrc2 + 5, csrc2, strlen(csrc2) + 1);
	ck_assert_str_eq(csrc, "GeeksGeeksfor");
	ck_assert_str_eq(csrc2, "GeeksGeeksfor");
	ck_assert_str_eq(csrc, csrc2);

#test check_memset
	char str[50] = "42 is a school";
	char str2[50] = "42 is a school";
	char longstr[9000] = "This is a long sentence with many many words. Many words.";
	clock_t t;
	double time_taken;

	printf("CHECKING MEMSET...\n");
	ck_assert_int_eq(sizeof(unsigned long), 8);
	memset(str + 3, '.', sizeof(char));
	ft_memset(str2 + 3, '.', sizeof(char));
	ck_assert_str_eq("42 .s a school", str);
	ck_assert_str_eq("42 .s a school", str2);
	ck_assert_str_eq(str, str2);

	memset(str + 4, '.', 7 * sizeof(char));
	ft_memset(str2 + 4, '.', 7 * sizeof(char));
	ck_assert_str_eq("42 ........ool", str);
	ck_assert_str_eq("42 ........ool", str2);
	ck_assert_str_eq(str, str2);

	t = clock();
	memset(longstr, '.', 8999 * sizeof(char));
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tmemset took %f to execute\n", time_taken);
	t = clock();
	ft_memset(longstr, '.', 8999 * sizeof(char));
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tft_memset took %f to execute\n", time_taken);

#test check_strcat
	printf("CHECKING STRCAT...\n");
	char dest[600];
	char dest2[600];
	char src[250];

	memset(dest, '.', 250);
	memset(dest2, '.', 250);
	dest[250] = '\0';
	dest2[250] = '\0';
	ck_assert_int_eq(strlen(dest), strlen(dest2));
	ck_assert_str_eq(dest, dest2);
	memset(src, 'S', 249);
	src[249] = '\0';
	ck_assert_int_eq(src[249], '\0');
	ck_assert_int_eq(strlen(src), 249);

	src[75] = 'A';
	strcat(dest, src);
	ft_strcat(dest2, src);
	ck_assert_str_eq(dest, dest2);
	ck_assert_int_eq(dest[250 + 75], 'A');
	ck_assert_int_eq(dest2[250 + 75], 'A');
	ck_assert_int_ne(dest[250 + 248], 0);
	ck_assert_int_ne(dest2[250 + 248], 0);
	ck_assert_int_eq(dest[250 + 249], 0);
	ck_assert_int_eq(dest2[250 + 249], 0);

#test check_strlcat
	printf("CHECKING STRLCAT...\n");
	char dest[600];
	char dest2[600];
	char src[250];

	memset(dest, '.', 250);
	memset(dest2, '.', 250);
	dest[250] = '\0';
	dest2[250] = '\0';
	ck_assert_int_eq(strlen(dest), strlen(dest2));
	ck_assert_str_eq(dest, dest2);
	memset(src, 'S', 249);
	src[249] = '\0';
	ck_assert_int_eq(src[249], '\0');
	ck_assert_int_eq(strlen(src), 249);

	src[75] = 'A';
	ck_assert_int_eq(strlcat(dest, src, 100), ft_strlcat(dest2, src, 100));
	ck_assert_str_eq(dest, dest2);

#test check_strncat
	printf("CHECKING STRNCAT...\n");
	char dest[600];
	char dest2[600];
	char src[250];

	memset(dest, '.', 250);
	memset(dest2, '.', 250);
	dest[250] = '\0';
	dest2[250] = '\0';
	ck_assert_int_eq(strlen(dest), strlen(dest2));
	ck_assert_str_eq(dest, dest2);
	memset(src, 'S', 249);
	src[249] = '\0';
	ck_assert_int_eq(src[249], '\0');
	ck_assert_int_eq(strlen(src), 249);

	src[75] = 'A';
	strncat(dest, src, 100);
	ft_strncat(dest2, src, 100);
	ck_assert_str_eq(dest, dest2);
	ck_assert_int_eq(dest[250 + 75], 'A');
	ck_assert_int_eq(dest2[250 + 75], 'A');
	ck_assert_int_ne(dest[250 + 99], 0);
	ck_assert_int_ne(dest2[250 + 99], 0);
	ck_assert_int_eq(dest[250 + 100], 0);
	ck_assert_int_eq(dest2[250 + 100], 0);

#test check_strcpy
	char dest[10000];
	char dest2[10000];
	char src[10000];
	char *ptr;
	char *ptr2;
	clock_t t;
	double time_taken;

	printf("CHECKING STRCPY...\n");
	memset(src, 'A', 9999);
	src[9999] = '\0';
	t = clock();
	strcpy(dest, src);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	ck_assert_str_eq(dest, src);
	printf("\tstrcpy took %f to execute\n", time_taken);
	t = clock();
	ft_strcpy(dest2, src);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	printf("\tft_strcpy took %f to execute\n", time_taken);
	ck_assert_str_eq(dest2, src);

	ck_assert_str_eq(dest, dest2);
	ck_assert_int_eq(dest[9998], 'A');
	ck_assert_int_eq(dest2[9998], 'A');
	ptr = dest;
	ptr2 = dest2;
	ck_assert_ptr_eq(ptr, dest);
	ck_assert_ptr_eq(ptr2, dest2);
	ptr += 9999;
	ptr2 += 9999;
	ck_assert_int_eq(*ptr, '\0');
	ck_assert_int_eq(*ptr2, '\0');

#test check_strchr
	char str[100];
	char *start;
	char *ptr;
	char *ptr2;

	printf("CHECKING STRCHR...\n");
	start = str;
	memset(str, '.', 50);
	memset(str + 50, 'A', 1);
	memset(str + 51, '.', 48);
	str[99] = '\0';
	ck_assert_int_eq(str[50], 'A');

	ptr = strchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[50]);

	ptr2 = ft_strchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[50]);

	ck_assert_ptr_eq(ptr, ptr2);
	ck_assert_ptr_eq(str, start);

#test check_strrchr
	char str[100];
	char *start;
	char *ptr;
	char *ptr2;
	char buf[] = "abcdedcba";

	printf("CHECKING STRRCHR...\n");
	start = str;
	memset(str, '.', 50);
	memset(str + 50, 'A', 1);
	memset(str + 51, '.', 48);
	str[99] = '\0';
	ck_assert_int_eq(str[50], 'A');

	ptr = strrchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[50]);

	ptr2 = ft_strrchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[50]);

	ck_assert_ptr_eq(ptr, ptr2);
	ck_assert_ptr_eq(str, start);

	memset(str + 51, 'A', 48);
	ptr = strrchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[98]);

	ptr2 = ft_strrchr(str, 'A');
	ck_assert_int_eq(*ptr, 'A');
	ck_assert_ptr_eq(ptr, &str[98]);

	ck_assert_ptr_eq(ptr, ptr2);
	ck_assert_ptr_eq(str, start);

	ck_assert_ptr_eq(strrchr(buf, 'z'), ft_strrchr(buf, 'z'));

#test check_strdup
	char src[9999];
	char src2[6] = "12345";
	char *res;
	char *res2;
	char *res3;
	clock_t t;
	double time_taken;

	printf("CHECKING STRDUP...\n");
	res3 = strdup(src2);
	ck_assert_int_eq(res3[6], '\0');
	ck_assert_str_eq(res3, src2);
	free(res3);
	res3 = NULL;
	ck_assert_ptr_eq(res3, 0);

	bzero(src, 9999);
	t = clock();
	res = strdup(src);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	printf("\tStrdup took %f to execute\n", time_taken);

	t = clock();
	res2 = ft_strdup(src);
	t = clock() - t;
	time_taken = ((double) t) / CLOCKS_PER_SEC;
	printf("\tft_strdup took %f to execute\n", time_taken);

	ck_assert_str_eq(res, src);
	ck_assert_str_eq(res2, src);
	ck_assert_int_eq(res[0], 0);
	ck_assert_int_eq(res2[0], 0);
	free(res);
	free(res2);

#test check_strlen
	char str[10] = "0123456789";
	char longstr[9000];
	clock_t t;
	double time_taken;
	int len;

	printf("CHECKING STRLEN...\n");
	ck_assert_int_eq(ft_strlen(str), strlen(str));
	memset(longstr, 'A', 9000);
	ck_assert_int_eq(ft_strlen(longstr), strlen(longstr));

	t = clock();
	len = strlen(longstr);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tStrlen took %f to execute\n", time_taken);

	t = clock();
	len = ft_strlen(longstr);
	t = clock() - t;
	time_taken = ((double)t) / CLOCKS_PER_SEC;
	printf("\tft_strlen took %f to execute\n", time_taken);

#test check_strstr
	printf("CHECKING STRSTR...\n");

	const char *largestring = "Foo BarBarx";
	const char *smallstring = "Barx";
	const char *s1 = "MZIRIBMZIRIBMZP";
    const char *s2 = "MZIRIBMZP";
	const char *s3 = "FF";
	const char *s4 = "see FF your FF return FF now FF";
	char *ret;
	char *ret2;

	ck_assert_ptr_eq(strstr(s3, s4), ft_strstr(s3, s4));
	ret = strstr(largestring, smallstring);
	ck_assert_int_eq(*ret, *smallstring);
	ck_assert_str_eq(ret, "Barx");

	ret2 = ft_strstr(largestring, smallstring);
	ck_assert_int_eq(*ret2, *smallstring);
	ck_assert_str_eq(ret2, "Barx");

	ck_assert_ptr_eq(ret, ret2);
	ck_assert_str_eq(strstr(s1, s2), ft_strstr(s1, s2));

#test check_strnstr
	printf("CHECKING STRNSTR...\n");

	const char *largestring = "Foo Bar Baz";
	const char *smallstring = "Bar";
	char *ret;
	char *ret2;
	char buf[10];
	char buf2[] = "ozarabozaraboze123";

	bzero(buf, 10);
	strcpy(buf, "un deux 9");

	ck_assert_ptr_eq(ft_strnstr(buf, "deux", 5), ((void*)0));
	ret = strnstr(largestring, smallstring, strlen(largestring));
	ck_assert_int_eq(*ret, *smallstring);
	ck_assert_str_eq(ret, "Bar Baz");

	ret2 = ft_strnstr(largestring, smallstring, strlen(largestring));
	ck_assert_int_eq(*ret2, *smallstring);
	ck_assert_str_eq(ret2, "Bar Baz");

	ck_assert_ptr_eq(ret, ret2);

	ret = strnstr(largestring, "", strlen(largestring));
	ret2 = ft_strnstr(largestring, "", strlen(largestring));

	ck_assert_str_eq(ret, largestring);
	ck_assert_str_eq(ret2, largestring);
	ck_assert_ptr_eq(ret, ret2);

	ck_assert_int_eq(strcmp(ft_strnstr(buf2, "ozaraboze", 15), "ozaraboze123"), 0);

#test check_strcmp
	printf("CHECKING STRCMP...\n");

	ck_assert_int_eq(ft_strcmp("A", "A"), strcmp("A", "A"));
	ck_assert_int_eq(ft_strcmp("", ""), strcmp("", ""));
	ck_assert_int_eq(ft_strcmp("ABc", "ABc"), strcmp("ABc", "ABc"));
	ck_assert_int_eq(ft_strcmp("abcdef", "ABCDEF"), strcmp("abcdef", "ABCDEF"));

#test check_strncmp
	printf("CHECKING STRNCMP...\n");

	ck_assert_int_eq(ft_strncmp("A", "A", 1), strncmp("A", "A", 1));
	ck_assert_int_eq(ft_strncmp("", "", 0), strncmp("", "", 0));
	ck_assert_int_eq(ft_strncmp("ABc", "ABc", 3), strncmp("ABc", "ABc", 3));
	ck_assert_int_eq(ft_strncmp("ABc", "ABc", 2), strncmp("ABc", "ABc", 2));
	ck_assert_int_eq(ft_strncmp("ABc", "ABc", 5), strncmp("ABc", "ABc", 5));
	ck_assert_int_eq(ft_strncmp("abcdef", "ABCDEF", 6), strncmp("abcdef", "ABCDEF", 6));

#test check_atoi
	printf("CHECKING ATOI...\n");

	ck_assert_int_eq(atoi("123"), ft_atoi("123"));
	ck_assert_int_eq(atoi("-123"), ft_atoi("-123"));
	ck_assert_int_eq(atoi("-12-3"), ft_atoi("-12-3"));
	ck_assert_int_eq(atoi("- 1"), ft_atoi("- 1"));
	ck_assert_int_eq(atoi("-+1"), ft_atoi("-+1"));
	ck_assert_int_eq(atoi("\t\t\t+1"), ft_atoi("\t\t\t+1"));
	ck_assert_int_eq(atoi("\t\t\t+\n1-"), ft_atoi("\t\t\t+\n1-"));
	ck_assert_int_eq(atoi("\n-\n1"), ft_atoi("\n-\n1"));
	ck_assert_int_eq(atoi("- 12-3"), ft_atoi("- 12-3"));
	ck_assert_int_eq(atoi("0"), ft_atoi("0"));
	ck_assert_int_eq(atoi("++0"), ft_atoi("++0"));
	ck_assert_int_eq(atoi("00+123"), ft_atoi("00+123"));
	ck_assert_int_eq(atoi("00000000000000001"), ft_atoi("00000000000000001"));
	ck_assert_int_eq(atoi("-00000000000001"), ft_atoi("-00000000000001"));
	ck_assert_int_eq(atoi("00-00000000000001"), ft_atoi("00-00000000000001"));
	ck_assert_int_eq(atoi("2147483647"), ft_atoi("2147483647"));
	ck_assert_int_eq(atoi("-2147483648"), ft_atoi("-2147483648"));
	ck_assert_int_eq(atoi("-9223372036854775808"), ft_atoi("-9223372036854775808"));
	ck_assert_int_eq(atoi("9223372036854775807"), ft_atoi("9223372036854775807"));
	ck_assert_int_eq(atoi("92233720368547758078"), ft_atoi("92233720368547758078"));
	ck_assert_int_eq(atoi("-9223372036854775807"), ft_atoi("-9223372036854775807"));

#test check_isalpha
	printf("CHECKING ISALPHA...\n");

	ck_assert_int_eq(isalpha('A'), ft_isalpha('A'));
	ck_assert_int_eq(isalpha('Z'), ft_isalpha('Z'));
	ck_assert_int_eq(isalpha('a'), ft_isalpha('a'));
	ck_assert_int_eq(isalpha('z'), ft_isalpha('z'));
	ck_assert_int_eq(isalpha('0'), ft_isalpha('0'));
	ck_assert_int_eq(isalpha('\n'), ft_isalpha('\n'));

#test check_isdigit
	printf("CHECKING ISDIGIT...\n");

	ck_assert_int_eq(isdigit('0'), ft_isdigit('0'));
	ck_assert_int_eq(isdigit('4'), ft_isdigit('4'));
	ck_assert_int_eq(isdigit('9'), ft_isdigit('9'));
	ck_assert_int_eq(isdigit('a'), ft_isdigit('a'));
	ck_assert_int_eq(isdigit('\n'), ft_isdigit('\n'));

#test check_isalphanum
	printf("CHECKING ISALNUM...\n");

	ck_assert_int_eq(isalnum('0'), ft_isalnum('0'));
	ck_assert_int_eq(isalnum('9'), ft_isalnum('9'));
	ck_assert_int_eq(isalnum('A'), ft_isalnum('A'));
	ck_assert_int_eq(isalnum('Z'), ft_isalnum('Z'));
	ck_assert_int_eq(isalnum('z'), ft_isalnum('z'));

#test check_isascii
	printf("CHECKING ISASCII...\n");

	ck_assert_int_eq(isascii('0'), ft_isascii('0'));
	ck_assert_int_eq(isascii('9'), ft_isascii('9'));
	ck_assert_int_eq(isascii('A'), ft_isascii('A'));
	ck_assert_int_eq(isascii('Z'), ft_isascii('Z'));
	ck_assert_int_eq(isascii('z'), ft_isascii('z'));
	ck_assert_int_eq(isascii('\r'), ft_isascii('\r'));
	ck_assert_int_eq(isascii(127), ft_isascii(127));
	ck_assert_int_eq(isascii(128), ft_isascii(128));
	ck_assert_int_eq(isascii(0), ft_isascii(0));
	ck_assert_int_eq(isascii(-1), ft_isascii(-1));

#test check_isprint
	printf("CHECKING ISPRINT...\n");

	ck_assert_int_eq(isprint('a'), ft_isprint('a'));
	ck_assert_int_eq(isprint(0), ft_isprint(0));
	ck_assert_int_eq(isprint(127), ft_isprint(127));
	ck_assert_int_eq(isprint(' '), ft_isprint(' '));
	ck_assert_int_eq(isprint('~'), ft_isprint('~'));
	ck_assert_int_eq(isprint('\n'), ft_isprint('\n'));
	ck_assert_int_eq(isprint('\r'), ft_isprint('\r'));

#test check_tolower
	printf("CHECKING TOLOWER...\n");

	ck_assert_int_eq(tolower('A'), ft_tolower('A'));
	ck_assert_int_eq(tolower('a'), ft_tolower('a'));
	ck_assert_int_eq(tolower('Z'), ft_tolower('Z'));
	ck_assert_int_eq(tolower('z'), ft_tolower('z'));
	ck_assert_int_eq(tolower('\n'), ft_tolower('\n'));

#test check_toupper
	printf("CHECKING TOUPPER...\n");

	ck_assert_int_eq(toupper('A'), ft_toupper('A'));
	ck_assert_int_eq(toupper('a'), ft_toupper('a'));
	ck_assert_int_eq(toupper('Z'), ft_toupper('Z'));
	ck_assert_int_eq(toupper('z'), ft_toupper('z'));
	ck_assert_int_eq(toupper('\n'), ft_toupper('\n'));

#test check_memalloc
	printf("CHECKING MEMALLOC...\n");

	void	*buf;

	buf = ft_memalloc(1000);
	ck_assert_int_eq(*(int *)buf, 0);
	ck_assert_int_eq(*((int *)buf + 999), 0);
	ck_assert_int_eq(*((int *)buf + 1000), 0);
	free(buf);

#test check_memdel
	printf("CHECKING MEMDEL...\n");

	void	*buf;
	void	*ptr;

	ptr = NULL;
	buf = ft_memalloc(1000);
	ft_memset(buf, 'A', 999);
	*((char *)buf + 999) = '\0';
	ck_assert_ptr_ne(buf, NULL);
	ft_memdel(&buf);
	ck_assert_ptr_eq(buf, NULL);
	ft_memdel(&ptr);

#test check_strnew
	printf("CHECKING STRNEW...\n");

	char	*buf;

	buf = ft_strnew(1000);
	ck_assert_int_eq(*(char *)buf, 0);
	ck_assert_int_eq(*((char *)buf + 999), 0);
	ck_assert_int_eq(*((char *)buf + 1000), 0);
	ck_assert_int_ne(*(char *)buf, 'A');
	ck_assert_int_ne(*(char *)buf + 123, 'A');
	free(buf);

#test check_strdel
	printf("CHECKING STRDEL...\n");

	char	*str;

	str = ft_strnew(100);
	ck_assert_ptr_ne(str, NULL);
	ft_strdel(&str);
	ck_assert_ptr_eq(str, NULL);

#test check_strclr
	printf("CHECKING STRCLR...\n");

	char *str;
	//char *str2 = "Hello";
	int i;

	str = ft_strnew(10);
	memset(str, 'A', 9);
	*((char *)str + 9) = '\0';
	ck_assert_str_eq(str, "AAAAAAAAA");
	ft_strclr(str);
	ck_assert_str_ne(str, "AAAAAAAAA");
	ck_assert_str_eq(str, "");

	i = 0;
	//ft_strclr(NULL);
	//ft_strclr(str2);
	//while (i < 6)
	//{
	//	ck_assert_msg(str2[i] != '\0', "Not fully cleared");
	//	i++;
	//}

#test check_striter
	printf("CHECKING STRITER...\n");

	char *str;

	str = ft_strnew(10);
	memset(str, 'a', 9);
	*((char *)str + 9) = '\0';
	ck_assert_str_eq(str, "aaaaaaaaa");
	ft_striter(str, &string_to_upper);
	ck_assert_str_ne(str, "aaaaaaaaa");
	ck_assert_str_eq(str, "AAAAAAAAA");

#test check_striteri
	printf("CHECKING STRITERI...\n");

	char *str;

	str = ft_strnew(10);
	memset(str, 'a', 9);
	*((char *)str + 9) = '\0';
	ck_assert_str_eq(str, "aaaaaaaaa");
	ft_striteri(str, &string_to_idx);
	ck_assert_str_ne(str, "aaaaaaaaa");
	ck_assert_str_eq(str, "012345678");

#test check_strmap
	printf("CHECKING STRMAP...\n");

	char *src = "abcdefgh";
	char *str;
	char  str2[] = "Hello";
	char  *ret;

	ft_strmap(NULL, NULL);
	ft_strmap("", NULL);
	ret = ft_strmap(str2, strmap_call);
	ck_assert_str_eq(ret, "Ifmmp");
	free(ret);

	str = ft_strmap(src, &char_to_upper);
	ck_assert_str_eq(str, "ABCDEFGH");


#test check_strmapi
	printf("CHECKING STRMAPI...\n");

	char *src = "abcdefgh";
	char *str;

	str = ft_strmapi(src, &char_to_idx);
	ck_assert_str_eq(str, "01234567");

#test check_strequ
	printf("CHECKING STREQU...\n");

	char *s1 = "abc";
	char *s2 = "abc";

	ck_assert_int_eq(ft_strequ(s1, s2), 1);
	ck_assert_int_eq(ft_strequ(s1, "abcd"), 0);
	ck_assert_int_eq(ft_strequ(s1, "ab"), 0);

#test check_strnequ
	printf("CHECKING STRNEQU...\n");

	char *s1 = "abc";
	char *s2 = "abc";

	ck_assert_int_eq(ft_strnequ(s1, s2, 3), 1);
	ck_assert_int_eq(ft_strnequ(s1, "abcd", 4), 0);
	ck_assert_int_eq(ft_strnequ(s1, "abcd", 3), 1);
	ck_assert_int_eq(ft_strnequ(s1, "ab", 3), 0);
	ck_assert_int_eq(ft_strnequ(s1, "ab", 2), 1);
	ck_assert_int_eq(ft_strnequ(s1, "abcddd", 1), 1);

#test check_substr
	printf("CHECKING STRSUB..\n");

	char *s = "One Two Three";
	char *sub;

	sub = ft_strsub(s, 4, 3);
	free(sub);
	ck_assert_str_eq(sub, "Two");
	sub = ft_strsub(s, 4, 9);
	free(sub);
	ck_assert_str_eq(sub, "Two Three");
	sub = ft_strsub(s, strlen(s), 1);
	ck_assert_str_eq(sub, "");
	free(sub);
	sub = ft_strsub(s, 0, strlen(s));
	ck_assert_str_eq(sub, s);
	free(sub);
	sub = ft_strsub(s, 0, 0);
	ck_assert_str_eq(sub, "");
	free(sub);

#test check_strjoin
	printf("CHECKING STRJOIN...\n");

	char *prefix = "One Two Three ";
	char *suffix = "Four Five Six";
	char *concat;

	concat = ft_strjoin(prefix, suffix);
	ck_assert_str_eq(concat, "One Two Three Four Five Six");
	free(concat);
	concat = ft_strjoin("", "");
	ck_assert_str_eq(concat, "");
	free(concat);
	concat = ft_strjoin("abc", "");
	ck_assert_str_eq(concat, "abc");
	ck_assert_int_eq(concat[3], '\0');
	free(concat);

#test check_strtrim
	printf("CHECKING STRTRIM...\n");

	char *s;

	s = ft_strtrim("  ABC   ");
	ck_assert_str_eq(s, "ABC");
	free(s);
	s = ft_strtrim("\n\n  ABC\n\n\t\t\n  \n");
	ck_assert_str_eq(s, "ABC");
	free(s);
	s = ft_strtrim("");
	ck_assert_str_eq(s, "");
	free(s);
	s = ft_strtrim("\n\n\n\n\n\n\t\t \t \t");
	ck_assert_str_eq(s, "");
	free(s);
	s = ft_strtrim("\n\n\n\n\n\n\t\t_ABC_ \t \t");
	ck_assert_str_eq(s, "_ABC_");
	free(s);
	s = ft_strtrim("  A B C  ");
	ck_assert_str_eq(s, "A B C");
	free(s);
	s = ft_strtrim("  A\n\tB\n\t\nC  ");
	ck_assert_str_eq(s, "A\n\tB\n\t\nC");
	free(s);
	s = ft_strtrim("  A   B   C  ");
	ck_assert_str_eq(s, "A   B   C");
	free(s);
	s = ft_strtrim("  A   B   C  ");
	ck_assert_str_eq(s, "A   B   C");
	free(s);
	s = ft_strtrim("  A   B   C\n\n\n \t\t \n ");
	ck_assert_str_eq(s, "A   B   C");
	free(s);
	s = ft_strtrim("   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ");
	ck_assert_str_eq(s, "Hello \t  Please\n Trim me !");
	free(s);
	s = ft_strtrim("   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !");
	ck_assert_str_eq(s, "Hello \t  Please\n Trim me !");
	free(s);

#test check_putchar
	printf("CHECKING PUTCHAR...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putchar('A');
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%c", str);
	ck_assert_str_eq(str, "A");
	fclose(fp);
	free(str);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putchar('z');
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%c", str);
	ck_assert_str_eq(str, "z");
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putchar_fd
	printf("CHECKING PUTCHAR_FD...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putchar_fd('A', 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%c", str);
	ck_assert_str_eq(str, "A");
	fclose(fp);
	free(str);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putchar_fd('z', 1);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%c", str);
	ck_assert_str_eq(str, "z");
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putstr
	printf("CHECKING PUTSTR...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	const char *sentence = "ThisIsASentence.";

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putstr(sentence);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, strlen(sentence));
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, sentence);
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putstr_fd
	printf("CHECKING PUTSTR_FD...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	const char *sentence = "ThisIsASentence.";

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putstr_fd(sentence, 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, strlen(sentence));
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, sentence);
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putendl
	printf("CHECKING PUTENDL...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	char newline[1];
	const char *sentence = "ThisIsASentence.";

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putendl(sentence);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, strlen(sentence) + 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	fscanf(fp, "%c", newline);
	ck_assert_str_eq(str, sentence);
	ck_assert_int_eq(*newline, '\n');
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putendl_fd
	printf("CHECKING PUTENDL...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	char newline[1];
	const char *sentence = "ThisIsASentence.";

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putendl_fd(sentence, 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, strlen(sentence) + 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	fscanf(fp, "%c", newline);
	ck_assert_str_eq(str, sentence);
	ck_assert_int_eq(*newline, '\n');
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putnbr
	printf("CHECKING PUTNBR...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putnbr(10);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 2);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, "10");
	fclose(fp);
	free(str);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putnbr(123456789);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 9);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, "123456789");
	fclose(fp);
	free(str);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putnbr(-123456789);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 10);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, "-123456789");
	fclose(fp);
	free(str);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putnbr(0);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 1);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, "0");
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_putnbr_fd
	printf("CHECKING PUTNBR_FD...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	int num;

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putnbr_fd(10, 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 2);
	rewind(fp);
	fscanf(fp, "%d", &num);
	ck_assert_int_eq(num, 10);
	fclose(fp);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putnbr_fd(123456789, 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 9);
	rewind(fp);
	fscanf(fp, "%d", &num);
	ck_assert_int_eq(num, 123456789);
	fclose(fp);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putnbr_fd(-123456789, 1);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 10);
	rewind(fp);
	fscanf(fp, "%d", &num);
	ck_assert_int_eq(num, -123456789);
	fclose(fp);

	remove("./tests/redir.txt");

#test check_strsplit
	printf("CHECKING STRSPLIT...\n");

	char **words;

	words = ft_strsplit("*One**Two***Three***!*", '*');
	ck_assert_str_eq(words[0], "One");
	ck_assert_str_eq(words[1], "Two");
	ck_assert_str_eq(words[2], "Three");
	ck_assert_str_eq(words[3], "!");
	//ck_assert_str_eq(words[4], "\0");

	words = ft_strsplit("*A*B*C*D*E", '*');
	ck_assert_str_eq(words[0], "A");
	ck_assert_str_eq(words[1], "B");
	ck_assert_str_eq(words[2], "C");
	ck_assert_str_eq(words[3], "D");
	ck_assert_str_eq(words[4], "E");
	//ck_assert_ptr_eq(words[5], NULL);

	words = ft_strsplit("   ABCDE", ' ');
	ck_assert_str_eq(words[0], "ABCDE");

#test check_itoa
	printf("CHECKING ITOA...\n");

	ck_assert_str_eq(ft_itoa(123), "123");
	ck_assert_str_eq(ft_itoa(10), "10");
	ck_assert_str_eq(ft_itoa(-123), "-123");
	ck_assert_str_eq(ft_itoa(0), "0");

	ck_assert_str_eq(ft_itoa(123456789), "123456789");
	ck_assert_str_eq(ft_itoa(2147483647), "2147483647");
	ck_assert_str_eq(ft_itoa(-2147483648), "-2147483648");

#test check_itoa_base
	printf("CHECKING ITOA BASE...\n");

	ck_assert_str_eq(ft_itoa_base(123, 10), "123");
	ck_assert_str_eq(ft_itoa_base(10, 10), "10");
	ck_assert_str_eq(ft_itoa_base(-123, 10), "-123");
	ck_assert_str_eq(ft_itoa_base(0, 10), "0");

	ck_assert_str_eq(ft_itoa_base(123456789, 10), "123456789");
	ck_assert_str_eq(ft_itoa_base(2147483647, 10), "2147483647");
	ck_assert_str_eq(ft_itoa_base(-2147483648, 10), "-2147483648");

	ck_assert_str_eq(ft_itoa_base(255, 16), "ff");
	ck_assert_str_eq(ft_itoa_base(-255, 16), "ff");
	ck_assert_str_eq(ft_itoa_base(255, 13), "168");
	ck_assert_str_eq(ft_itoa_base(255, 13), "168");

	ck_assert_str_eq(ft_itoa_base(16, 2), "10000");
	ck_assert_str_eq(ft_itoa_base(0, 2), "0");
	ck_assert_str_eq(ft_itoa_base(222, 5), "1342");
	
	ck_assert_str_eq(ft_itoa_base(140732707748056, 16), "7ffee30db8d8");

#test check_lstnew
	printf("CHECKING LSTNEW...\n");

	t_list *node;
	int nb;

	node = ft_lstnew("ABC", sizeof(char) * 4);
	ck_assert_str_eq("ABC", (char *)node->content);
	ck_assert_int_eq(4, node->content_size);
	ck_assert_ptr_eq(0, node->next);
	free(node->content);
	free(node);
	node = ft_lstnew(NULL, 10);
	ck_assert_ptr_eq(NULL, node->content);
	ck_assert_int_eq(0, node->content_size);
	ck_assert_ptr_eq(0, node->next);
	free(node->content);
	free(node);
	nb = 98765;
	node = ft_lstnew(&nb,sizeof(int));
	ck_assert_int_eq(nb, *(int *)node->content);
	ck_assert_int_eq(sizeof(int), node->content_size);
	ck_assert_ptr_eq(0, node->next);
	free(node->content);
	free(node);

#test check_lstdelone
	printf("CHECKING LSTDELONE...\n");

	t_list *node;

	node = ft_lstnew("ABC", sizeof(char) * 4);
	ft_lstdelone(&node, &lst_del_str);
	ck_assert_ptr_eq(node, NULL);

#test check_lstdel
	printf("CHECKING LSTDEL...\n");

	t_list *n1;
	t_list *n2;
	t_list *n3;
	t_list *n4;

	n1 = ft_lstnew("ABC", sizeof(char) * 4);
	n2 = ft_lstnew("ABC", sizeof(char) * 4);
	n3 = ft_lstnew("ABC", sizeof(char) * 4);
	n4 = ft_lstnew("ABC", sizeof(char) * 4);
	n1->next = n2;
	n2->next = n3;
	n3->next = n4;

	ft_lstdel(&n1, &lst_del_str);
	ck_assert_ptr_eq(n1, NULL);
	//ck_assert_ptr_eq(n2, NULL);
	//ck_assert_ptr_eq(n3, NULL);
	//ck_assert_ptr_eq(n4, NULL);

#test check_lstadd
	printf("CHECKING LSTADD...\n");

	t_list *n1;
	t_list *n2;
	t_list *new;

	n1 = ft_lstnew("ABC", sizeof(char) * 4);
	n2 = ft_lstnew("DEF", sizeof(char) * 4);
	new = ft_lstnew("HIJ", sizeof(char) * 4);
	n1->next = n2;
	ft_lstadd(&n1, new);

	ck_assert_str_eq("HIJ", (char *)n1->content);

#test check_lstiter
	printf("CHECKING LSTITER...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	t_list *n1;
	t_list *n2;

	n1 = ft_lstnew("ABC", sizeof(char) * 4);
	n2 = ft_lstnew("DEF", sizeof(char) * 4);
	n1->next = n2;

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_lstiter(n1, &print_lst_content);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 6);
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	ck_assert_str_eq(str, "ABCDEF");
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test check_lstmap
	printf("CHECKING LSTMAP...\n");

	t_list *n1;
	t_list *n2;
	t_list *n3;
	t_list *new;

	n1 = ft_lstnew("abc", sizeof(char) * 4);
	n2 = ft_lstnew("def", sizeof(char) * 4);
	n3 = ft_lstnew("hij", sizeof(char) * 4);
	n1->next = n2;
	n2->next = n3;

	new = ft_lstmap(n1, &create_elem_map);
	ck_assert_ptr_ne(new, NULL);
	//ck_assert_str_eq("ABC", new->content);

#test	check_ft_str_replace
	printf("CHECKING STR REPLACE...\n");

	char str[] = "AAAxxx AAAxxx A ";

	ft_strcre(str, 'A', 'x');
	ck_assert_str_eq(str, "xxxxxx xxxxxx x ");

#test	check_ft_putstrs
	printf("CHECKING PUTSTRS...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char **str;
	char *buf;

	ft_putstrs(NULL);
	str = malloc(sizeof(*str) * 3);
	str[0] = ft_strdup("abc");
	str[1] = ft_strdup("def");
	str[2] = ft_strdup("ghi");

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	ft_putstrs((const char **) str);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 12);
	buf = (char *)malloc(sizeof(char) * 4);
	rewind(fp);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "abc");
	bzero(buf, 4);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "def");
	bzero(buf, 4);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "ghi");
	bzero(buf, 4);
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test	check_ft_putstrs_fd
	printf("CHECKING PUTSTRS_FD...\n");

	struct stat st;
	int bytes_written;
	FILE *fp;
	char **str;
	char *buf;

	ft_putstrs_fd(NULL, 2);
	str = malloc(sizeof(*str) * 3);
	str[0] = ft_strdup("abc");
	str[1] = ft_strdup("def");
	str[2] = ft_strdup("ghi");

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stderr);
	ft_putstrs_fd((const char **)str, 2);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 12);
	buf = (char *)malloc(sizeof(char) * 4);
	rewind(fp);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "abc");
	bzero(buf, 4);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "def");
	bzero(buf, 4);
	fscanf(fp, "%s", buf);
	ck_assert_str_eq(buf, "ghi");
	bzero(buf, 4);
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test	check_btree_create_node
	printf("CHECKING BTREE CREATE NODE...\n");

	t_btree *node;
	int nb1;

	nb1 = 10;
	node = btree_create_node(&nb1);
	ck_assert_ptr_ne(node, NULL);
	ck_assert_ptr_eq(node->left, NULL);
	ck_assert_ptr_eq(node->right, NULL);
	ck_assert_ptr_eq((int *)node->item, &nb1);
	ck_assert_int_eq(*((int *)node->item), nb1);

#test	check_btree_insert_node
	printf("CHECKING BTREE INSERT NODE...\n");

	t_btree *node;
	int nb1;
	int nb2;
	int nb3;
	int nb4;
	int nb5;

	nb1 = 10;
	nb2 = 25;
	nb3 = 5;
	nb4 = 99;
	nb5 = 120;
	node = btree_create_node(&nb1);
	btree_insert_node(&node, &nb2, &btree_cmpf_int);
	btree_insert_node(&node, &nb3, &btree_cmpf_int);
	btree_insert_node(&node, &nb3, &btree_cmpf_int);
	btree_insert_node(&node, &nb4, &btree_cmpf_int);
	btree_insert_node(&node, &nb5, &btree_cmpf_int);
	ck_assert_int_eq(*((int *)node->item), nb1);
	ck_assert_int_eq(*((int *)node->right->item), nb2);
	ck_assert_int_eq(*((int *)node->left->item), nb3);
	ck_assert_int_eq(*((int *)node->right->right->item), nb4);
	ck_assert_int_eq(*((int *)node->right->right->right->item), nb5);

#test	check_btree_minvalue_node
	printf("CHECKING BTREE MINVALUE NODE...\n");

	t_btree *node;
	t_btree	*min_node;
	int nb1;
	int nb2;
	int nb3;
	int nb4;

	nb1 = 10;
	nb2 = 25;
	nb3 = 5;
	nb4 = 99;

	node = btree_create_node(&nb1);
	btree_insert_node(&node, &nb2, &btree_cmpf_int);
	btree_insert_node(&node, &nb3, &btree_cmpf_int);
	btree_insert_node(&node, &nb3, &btree_cmpf_int);
	btree_insert_node(&node, &nb4, &btree_cmpf_int);

	min_node = btree_minvalue_node(&node);
	ck_assert_int_eq(*((int *)min_node->item), 5);

#test	check_btree_update_node
	printf("CHECKING BTREE UPDATE NODE...\n");

	t_btree *node;
	int nb1;
	int nb2;

	nb1 = 1;
	node = btree_create_node(&nb1);
	nb2 = 99;

	ck_assert_int_eq(*((int *)node->item), nb1);
	btree_update_node(&node, &nb2, &btree_updatef_int);
	ck_assert_int_eq(*((int *)node->item), nb2);
	btree_update_node(&node, &nb1, &btree_updatef_int);
	ck_assert_int_eq(*((int *)node->item), nb1);

#test	check_btree_delete_node
	printf("CHECKING BTREE DELETE NODE...\n");

	t_btree *node;
	int nb1;
	int nb2;
	int nb3;
	int nb4;
	int nb5;

	nb1 = 10;
	nb2 = 25;
	nb3 = 5;
	nb4 = 99;
	nb5 = 120;

	t_btree_fns *fns;

	fns = (t_btree_fns *)ft_memalloc(sizeof(*fns));
	fns->cmpf = &btree_cmpf_int;
	fns->delf = &btree_deletef_int;
	fns->updatef = &btree_updatef_int;

	node = btree_create_node(&nb1);
	btree_insert_node(&node, &nb2, &btree_cmpf_int);
	btree_insert_node(&node, &nb3, &btree_cmpf_int);
	btree_insert_node(&node, &nb4, &btree_cmpf_int);
	btree_insert_node(&node, &nb5, &btree_cmpf_int);

	node = btree_remove_node(&node, &nb1, fns);
	//printf("LEVEL COUNT %d (rm %d): ", btree_level_count(node), nb1);
	//btree_apply_infix(node, &btree_print_int);
	//printf("\n");
	ck_assert_int_ne(*((int *)node->item), nb1);
	ck_assert_int_eq(*((int *)node->item), nb2);

	node = btree_remove_node(&node, &nb4, fns);
	//printf("LEVEL COUNT %d (rm %d): ", btree_level_count(node), nb4);
	//btree_apply_infix(node, &btree_print_int);
	//printf("\n");
	ck_assert_int_eq(*((int *)node->item), nb2);
	ck_assert_int_eq(*((int *)node->left->item), nb3);
	ck_assert_int_eq(*((int *)node->right->item), nb5);

	node = btree_remove_node(&node, &nb2, fns);
	//printf("LEVEL COUNT %d (rm %d): ", btree_level_count(node), nb2);
	//btree_apply_infix(node, &btree_print_int);
	//printf("\n");
	ck_assert_int_eq(*((int *)node->item), nb5);
	ck_assert_int_eq(*((int *)node->left->item), nb3);
	ck_assert_ptr_eq(node->right, NULL);

	node = btree_remove_node(&node, &nb3, fns);
	//printf("LEVEL COUNT %d (rm %d): ", btree_level_count(node), nb3);
	//btree_apply_infix(node, &btree_print_int);
	//printf("\n");
	ck_assert_int_eq(*((int *)node->item), nb5);
	ck_assert_ptr_eq(node->right, NULL);
	ck_assert_ptr_eq(node->left, NULL);

	node = btree_remove_node(&node, &nb5, fns);
	//printf("LEVEL COUNT %d (rm %d): ", btree_level_count(node), nb5);
	//btree_apply_infix(node, &btree_print_int);
	//printf("\n");
	ck_assert_ptr_eq(node, NULL);

#test check_stack_push
	printf("CHECKING STACK PUSH...\n");

	t_stack *top;
	int nb1;
	int nb2;

	nb1 = 10;
	nb2 = 25;

	stack_push(&top, &nb1);
	stack_push(&top, &nb2);

	ck_assert_ptr_eq(top->data, &nb2);
	ck_assert_ptr_eq(top->next->data, &nb1);
	ck_assert_int_eq(*((int *)top->data), nb2);
	ck_assert_int_eq(*((int *)top->next->data), nb1);

#test check_stack_isempty
	printf("CHECKING STACK IS EMPTY...\n");

	t_stack *top;
	int nb1;

	nb1 = 10;

	top = NULL;
	ck_assert_int_eq(stack_isempty(&top), 1);
	stack_push(&top, &nb1);
	ck_assert_int_eq(stack_isempty(&top), 0);


#test check_stack_pop
	printf("CHECKING STACK POP...\n");

	t_stack *top;
	int nb1;
	int nb2;

	nb1 = 10;
	nb2 = 25;

	stack_push(&top, &nb1);
	stack_push(&top, &nb2);

	ck_assert_int_eq(*((int *)stack_pop(&top)), nb2);
	ck_assert_int_eq(*((int *)stack_pop(&top)), nb1);

#test check_stack_iter
	printf("CHECKING STACK ITER...\n");

	t_stack *top;
	int nb1;
	int nb2;
	int nb3;
	int nb4;
	struct stat st;
	int bytes_written;
	FILE *fp;
	char *buf;

	nb1 = 10;
	nb2 = 25;
	nb3 = -5;
	nb4 = 99;

	top = NULL;
	stack_push(&top, &nb1);
	stack_push(&top, &nb2);
	stack_push(&top, &nb3);
	stack_push(&top, &nb4);

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	stack_iter(&top, &stack_print_int);
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	ck_assert_int_eq(bytes_written, 8);
	buf = (char *)malloc(sizeof(char) * bytes_written);
	rewind(fp);
	fscanf(fp, "%s", buf);
	fclose(fp);

	ck_assert_str_eq("99-52510", buf);

	remove("./tests/redir.txt");

#test	check_getwchar
	printf("CHECKING GET WIDE CHARACTER...\n");

	ft_putstr(ft_getwchar(044));
	printf("\n");
	ft_putstr(ft_getwchar(0242));
	printf("\n");
	ft_putstr(ft_getwchar(020254));
	printf("\n");
	ft_putstr(ft_getwchar(0201510));
	printf("\n");
